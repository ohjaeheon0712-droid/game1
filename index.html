<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>High-Stack: Intelligent Camera Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; background: rgba(0,0,0,0.85); padding: 20px; border-radius: 12px; border: 2px solid #444; min-width: 200px; }
        canvas { background: #ffffff; border: 5px solid #333; box-shadow: 0 0 50px rgba(0,0,0,0.6); }
        #score { color: #00ff88; font-weight: bold; font-size: 1.8em; }
        #rank { color: #ffeb3b; font-weight: bold; font-size: 1.2em; margin-top: 5px; }
        #cooldown { color: #ff4444; font-weight: bold; margin-top: 10px; font-size: 1.1em; }
        #loading { position: absolute; color: #ffeb3b; font-size: 24px; font-weight: bold; z-index: 100; text-align: center; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="loading">카메라 지능형 추적 시스템 적용 중...</div>
    <div id="ui">
        <div>Blocks: <span id="score">0</span></div>
        <div id="rank">Rank: 브론즈</div>
        <div id="cooldown">READY!</div>
        <hr style="border: 0; border-top: 1px solid #444; margin: 10px 0;">
        <div style="font-size: 0.85em; color: #ccc;">[A] 회전 | [Click] 낙하 | [R] 재시작</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const { Engine, Bodies, Composite, Body, Common, Vertices, Events } = Matter;
        Common.setDecomp(decomp);

        const engine = Engine.create({
            enableSleeping: true, // 수면 모드 활성화 (멈춘 물체 감지용)
            positionIterations: 12,
            velocityIterations: 12
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 750;
        engine.gravity.y = 1.3;

        const FIXED_SIZE = 100;
        const GROUND_WIDTH = 500;
        const GROUND_Y = 720; // ⭐ 바닥을 더 낮춤
        const GROUND_HEIGHT = 60;

        let viewOffset = 0; 
        let maxViewOffset = 0; 

        function getRank(s) {
            if (s >= 30) return { name: "신 (GOD)", color: "#ffffff" };
            if (s >= 22) return { name: "다이아몬드", color: "#00e5ff" };
            if (s >= 15) return { name: "플래티넘", color: "#00ff88" };
            if (s >= 9)  return { name: "골드", color: "#ffeb3b" };
            if (s >= 5)  return { name: "실버", color: "#e0e0e0" };
            return { name: "브론즈", color: "#cd7f32" };
        }

        function getPreciseVertices(img, targetSize) {
            const scanCanvas = document.createElement('canvas');
            const sCtx = scanCanvas.getContext('2d');
            scanCanvas.width = img.width; scanCanvas.height = img.height;
            sCtx.drawImage(img, 0, 0);
            const fullData = sCtx.getImageData(0, 0, img.width, img.height).data;
            let minX = img.width, minY = img.height, maxX = 0, maxY = 0;
            let found = false;
            for (let y = 0; y < img.height; y++) {
                for (let x = 0; x < img.width; x++) {
                    if (fullData[(y * img.width + x) * 4 + 3] > 50) {
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                        found = true;
                    }
                }
            }
            const tCanvas = document.createElement('canvas');
            tCanvas.width = targetSize; tCanvas.height = targetSize;
            const tc = tCanvas.getContext('2d');
            tc.drawImage(img, minX, minY, maxX-minX, maxY-minY, 0, 0, targetSize, targetSize);
            const data = tc.getImageData(0, 0, targetSize, targetSize).data;
            let pts = [];
            for (let y = 0; y < targetSize; y += 3) {
                for (let x = 0; x < targetSize; x += 3) {
                    if (data[(y * targetSize + x) * 4 + 3] > 120) pts.push({ x, y });
                }
            }
            const hull = Vertices.hull(pts);
            const ctr = Vertices.centre(hull);
            return {
                vertices: hull.map(p => ({ x: p.x - ctr.x, y: p.y - ctr.y })),
                img: tCanvas
            };
        }

        const configs = {
            "img1": { path: "images/9aff562fdf575bcacbea3cd3330c576e (1).png" },
            "img2": { path: "images/9aff562fdf575bcacbea3cd3330c576e (2).png" },
            "img3": { path: "images/9aff562fdf575bcacbea3cd3330c576e (3).png" },
            "img4": { path: "images/9aff562fdf575bcacbea3cd3330c576e.png" },
            "img5": { path: "images/9aff562fdf575bcacbea3cd3330c576e-Photoroom.png" },
            "img6": { path: "images/a9d63d62885a7884a2bbc333dfce56ab-Photoroom.png" },
            "img7": { path: "images/f3e9e04346d7e58e0603680d1bd2ea13-Photoroom.png" },
            "img8": { path: "images/63a1aff59ec47d0b600ea81c51125b1d (1).png" }
        };

        const ground = Bodies.rectangle(400, GROUND_Y, GROUND_WIDTH, GROUND_HEIGHT, { 
            isStatic: true, friction: 1.0, frictionStatic: 100 
        });
        Composite.add(engine.world, ground);

        let blocks = [];
        let score = 0;
        let keys = Object.keys(configs);
        let ghost = { x: 400, y: 80, angle: 0, type: keys[0] };
        let gameOver = false;
        let isReady = false;
        let cooldownActive = false;
        let cooldownRemaining = 0;

        let loaded = 0;
        keys.forEach(k => {
            const i = new Image(); i.src = configs[k].path;
            i.onload = () => {
                const res = getPreciseVertices(i, FIXED_SIZE);
                configs[k].vertices = res.vertices;
                configs[k].imgElem = res.img;
                if (++loaded === keys.length) {
                    isReady = true;
                    document.getElementById('loading').style.display = 'none';
                }
            };
        });

        window.addEventListener('mousemove', (e) => {
            const r = canvas.getBoundingClientRect();
            ghost.x = (e.clientX - r.left) * (canvas.width / r.width);
        });

        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'a') ghost.angle += 0.5;
            if (e.key.toLowerCase() === 'r') location.reload();
        });

        window.addEventListener('mousedown', () => {
            if (!isReady || gameOver || cooldownActive) return;
            const conf = configs[ghost.type];
            const dropY = 80 - viewOffset; 
            const b = Bodies.fromVertices(ghost.x, dropY, [conf.vertices], {
                friction: 1.0, frictionStatic: 100.0, restitution: 0, density: 1.5, sleepThreshold: 60
            });
            if (b) {
                Body.setAngle(b, ghost.angle);
                b.customType = ghost.type;
                blocks.push(b);
                Composite.add(engine.world, b);
                score++;
                document.getElementById('score').innerText = score;
                const r = getRank(score);
                document.getElementById('rank').innerText = "Rank: " + r.name;
                document.getElementById('rank').style.color = r.color;
                startCooldown();
            }
        });

        function startCooldown() {
            cooldownActive = true;
            cooldownRemaining = 3;
            const cd = document.getElementById('cooldown');
            const t = setInterval(() => {
                if (--cooldownRemaining > 0) cd.innerText = `COOLDOWN: ${cooldownRemaining}s`;
                else { clearInterval(t); cd.innerText = "READY!"; cooldownActive = false; ghost.type = keys[Math.floor(Math.random()*keys.length)]; ghost.angle = 0; }
            }, 1000);
            cd.innerText = `COOLDOWN: 3s`;
        }

        function draw() {
            Engine.update(engine);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ⭐ 카메라 로직: 수면 상태(완전히 멈춘) 블록만 추적
            let highestStableY = GROUND_Y;
            blocks.forEach(b => {
                // 블록이 '수면(Sleeping)' 상태이거나 속도가 0에 가깝고,
                // 생성 지점(현재 뷰 기준 200px)보다 아래에 있는 경우에만 타워 높이로 인정
                if ((b.isSleeping || Math.abs(b.velocity.y) < 0.1) && 
                     b.position.y < highestStableY && 
                     b.position.y > (150 - viewOffset)) { // 생성 영역 보호
                    highestStableY = b.position.y;
                }
            });
            
            // 타워 높이가 화면 상단 280px 지점까지 올라오면 카메라 이동
            const targetOffset = highestStableY < 280 ? 280 - highestStableY : 0;
            if (targetOffset > maxViewOffset) maxViewOffset = targetOffset;
            
            viewOffset += (maxViewOffset - viewOffset) * 0.05;

            ctx.save();
            ctx.translate(0, viewOffset);

            // 바닥
            ctx.fillStyle = "#e67e22";
            ctx.fillRect(400-(GROUND_WIDTH/2), GROUND_Y-(GROUND_HEIGHT/2), GROUND_WIDTH, GROUND_HEIGHT);
            ctx.strokeStyle = "#a84300"; ctx.lineWidth = 4;
            ctx.strokeRect(400-(GROUND_WIDTH/2), GROUND_Y-(GROUND_HEIGHT/2), GROUND_WIDTH, GROUND_HEIGHT);

            blocks.forEach(b => {
                const conf = configs[b.customType];
                ctx.save();
                ctx.translate(b.position.x, b.position.y);
                ctx.rotate(b.angle);
                if (b.isSleeping) ctx.globalAlpha = 0.95;
                ctx.drawImage(conf.imgElem, -50, -50, 100, 100);
                ctx.restore();

                ctx.beginPath();
                b.parts.forEach(p => {
                    p.vertices.forEach((v, i) => i===0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y));
                    ctx.lineTo(p.vertices[0].x, p.vertices[0].y);
                });
                ctx.strokeStyle = b.isSleeping ? "#3498db" : "#e74c3c";
                ctx.stroke();

                if (b.position.y > GROUND_Y + 500) gameOver = true;
            });
            ctx.restore();

            // 고스트 (화면 상단 고정)
            if (isReady && !gameOver) {
                const conf = configs[ghost.type];
                ctx.save(); ctx.globalAlpha = cooldownActive ? 0.15 : 0.5;
                ctx.translate(ghost.x, 80); ctx.rotate(ghost.angle);
                ctx.drawImage(conf.imgElem, -50, -50, 100, 100);
                ctx.restore();
            }

            if (gameOver) {
                ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle = "#ff4444"; ctx.textAlign = "center"; ctx.font = "bold 60px Arial";
                ctx.fillText("GAME OVER", 400, 350);
            }
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
